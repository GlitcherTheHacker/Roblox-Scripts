-- Attacker Tracker v2
-- Drop in StarterPlayerScripts or run locally in your test place

-- ========== CONFIG ==========
local INACTIVITY_TIMEOUT = 5          -- seconds until an attacker is removed
local SCAN_RADIUS = 0                 -- 0 => unlimited (global); otherwise number (studs)
local POLL_INTERVAL = 0.25            -- UI / housekeeping tick
local HISTORY_MAX = 200
local HIT_ATTRIBUTION_WINDOW = 6      -- seconds: recent hit considered for kill credit
local MAX_HISTORY_SHOWN = 20

-- ========== SERVICES ==========
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Workspace = game:GetService("Workspace")

-- ========== STATE ==========
local attackers = {}      -- attackers[name] = { lastHit = tick(), hits = n, firstSeen = tick() }
local history = {}        -- array of {name, timeFirst, timeLast, hits}
local recentHitLog = {}   -- recentHitLog[victimName] = { attacker = name, time = tick() }
local FightRemote = nil
local uiOpen = false
local selectedKillTarget = nil
local killStats = { kills = 0, deaths = 0 }

-- ========== UTILITIES ==========
local function findFightRemote()
    -- look in ReplicatedStorage for common remote names
    local candidates = {"FightEvent", "Fight", "DamageEvent", "CombatEvent"}
    for _, name in ipairs(candidates) do
        local r = ReplicatedStorage:FindFirstChild(name)
        if r and r:IsA("RemoteEvent") then return r end
    end
    for _, v in ipairs(ReplicatedStorage:GetChildren()) do
        if v:IsA("RemoteEvent") and v.Name:lower():match("fight") then return v end
    end
    return nil
end

local function now() return tick() end

local function clamp(n, a, b) return math.max(a, math.min(b, n)) end

-- Register / refresh attacker (only call when LocalPlayer was the victim)
local function registerAttacker(name)
    if not name or name == "" then return end
    if name == LocalPlayer.Name then return end -- never register yourself
    local t = now()
    local e = attackers[name]
    if e then
        e.lastHit = t
        e.hits = e.hits + 1
    else
        attackers[name] = { lastHit = t, hits = 1, firstSeen = t }
    end
    -- also update recentHitLog for attribution (victim is LocalPlayer)
    recentHitLog[LocalPlayer.Name] = { attacker = name, time = t }
end

local function archiveAttacker(name)
    local e = attackers[name]
    if not e then return end
    table.insert(history, 1, { name = name, timeFirst = e.firstSeen, timeLast = e.lastHit, hits = e.hits })
    while #history > HISTORY_MAX do table.remove(history) end
    attackers[name] = nil
end

local function archiveAllExpired()
    local t = now()
    for name,e in pairs(attackers) do
        if t - e.lastHit >= INACTIVITY_TIMEOUT then
            archiveAttacker(name)
        end
    end
end

-- record a general recent hit (victimName string, attackerName string)
local function recordRecentHit(victimName, attackerName)
    if not victimName or not attackerName then return end
    recentHitLog[victimName] = { attacker = attackerName, time = now() }
end

-- Try to safely get a Player from an Instance or string
local function playerFromInstance(inst)
    if not inst then return nil end
    -- if it's a Player object
    if typeof(inst) == "Instance" then
        if inst:IsA("Player") then return inst end
        -- if it's a Humanoid/Part inside character, get player
        local model = inst:FindFirstAncestorWhichIsA("Model")
        if model then
            for _, pl in ipairs(Players:GetPlayers()) do
                if pl.Character == model then return pl end
            end
        end
    end
    return nil
end

-- ========== DETECTION METHODS ==========
-- Primary: Listen to FightRemote onClientEvent if available
local function handleFightRemoteEvent(...)
    local args = {...}
    -- Try to detect attacker/victim in many shapes
    -- Typical shapes:
    -- 1) (attackerPlayer, victimPlayer, damage)
    -- 2) ({attacker=player, victim=player, dmg=...})
    -- 3) (victimPlayer, attackerName) etc.
    -- We'll search args for Player instances or strings.

    local attackerName, victimName = nil, nil

    for i,a in ipairs(args) do
        if typeof(a) == "Instance" and a:IsA("Player") then
            -- if we haven't chosen one, assign as attacker or victim heuristically:
            -- - if first found and next arg is Player, assume attacker then victim
            if not attackerName then
                attackerName = a.Name
            elseif not victimName then
                victimName = a.Name
            end
        elseif type(a) == "table" then
            -- check table entries
            if a.attacker and typeof(a.attacker) == "Instance" and a.attacker:IsA("Player") then
                attackerName = a.attacker.Name
            end
            if a.victim and typeof(a.victim) == "Instance" and a.victim:IsA("Player") then
                victimName = a.victim.Name
            end
            if a.attackerName and type(a.attackerName) == "string" then attackerName = attackerName or a.attackerName end
            if a.victimName and type(a.victimName) == "string" then victimName = victimName or a.victimName end
        elseif type(a) == "string" then
            -- ambiguous string
            -- skip for now
        end
    end

    -- best-effort: if two players in args and we couldn't tell which is which, assume first=attacker second=victim
    if not victimName and #args >= 2 and typeof(args[1]) == "Instance" and typeof(args[2]) == "Instance" then
        if args[1]:IsA("Player") and args[2]:IsA("Player") then
            attackerName = attackerName or args[1].Name
            victimName = victimName or args[2].Name
        end
    end

    -- If victim is LocalPlayer, register attacker
    if victimName == LocalPlayer.Name and attackerName and attackerName ~= LocalPlayer.Name then
        registerAttacker(attackerName)
        recordRecentHit(victimName, attackerName)
    elseif attackerName == LocalPlayer.Name and victimName then
        -- we attacked someone -> don't register them as attackers
        -- but record recent hit log for kill attribution
        recordRecentHit(victimName, attackerName)
    end
end

-- Secondary: Touch detection on LocalPlayer character parts (fast, reliable for touch-based tools)
local touchConnections = {}
local function connectTouchDetectors(character)
    if not character then return end
    -- connect to all BaseParts in character
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            if not touchConnections[part] then
                local conn = part.Touched:Connect(function(otherPart)
                    -- when something touches our character, detect if it belongs to a player's tool
                    if not otherPart or not otherPart.Parent then return end
                    local ownerPl = playerFromInstance(otherPart)
                    if ownerPl and ownerPl ~= LocalPlayer then
                        -- ensure it's a tool part (touch transmitter may be tool.Handle or hitbox)
                        local ancTool = otherPart:FindFirstAncestorWhichIsA("Tool")
                        if ancTool then
                            -- register as attacker immediately
                            registerAttacker(ownerPl.Name)
                            recordRecentHit(LocalPlayer.Name, ownerPl.Name)
                        end
                    end
                end)
                touchConnections[part] = conn
            end
        end
    end
end

local function disconnectTouchDetectors()
    for part, conn in pairs(touchConnections) do
        if conn and conn.Connected then pcall(function() conn:Disconnect() end) end
        touchConnections[part] = nil
    end
end

-- Tertiary: Health fallback scanning (broader heuristics)
local function scanForLikelyAttacker()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return nil end
    local myPos = char.HumanoidRootPart.Position

    local best, bestScore = nil, math.huge
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local root = pl.Character.HumanoidRootPart
            local dist = (root.Position - myPos).Magnitude
            if SCAN_RADIUS == 0 or dist <= SCAN_RADIUS then
                -- prefer players who hold tools and are closer
                local hasTool = false
                for _, c in ipairs(pl.Character:GetChildren()) do
                    if c:IsA("Tool") then hasTool = true; break end
                end
                local score = dist - (hasTool and 5 or 0)
                if score < bestScore then
                    bestScore = score
                    best = pl
                end
            end
        end
    end

    if best then return best.Name end
    return nil
end

-- Creator tag scan near workspace (common pattern for ranged/projectiles)
local function findCreatorFromWorkspaceNearby()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return nil end
    local rootPos = char.HumanoidRootPart.Position

    for _, object in ipairs(Workspace:GetDescendants()) do
        if object:IsA("BasePart") then
            local d = (object.Position - rootPos).Magnitude
            if SCAN_RADIUS == 0 or d <= SCAN_RADIUS then
                local creator = object:FindFirstChild("creator") or object:FindFirstChild("Creator") or object:FindFirstChild("Owner")
                if creator and creator.Value then
                    if typeof(creator.Value) == "Instance" and creator.Value:IsA("Player") then
                        return creator.Value.Name
                    elseif type(creator.Value) == "string" then
                        return creator.Value
                    end
                end
                local parent = object.Parent
                if parent then
                    local ctag = parent:FindFirstChild("creator") or parent:FindFirstChild("Creator")
                    if ctag and ctag.Value and typeof(ctag.Value) == "Instance" and ctag.Value:IsA("Player") then
                        return ctag.Value.Name
                    end
                end
            end
        end
    end
    return nil
end

-- Health watcher for LocalPlayer: determines changes and tries heuristics
local lastHealth = nil
local function hookHealthWatcher()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    lastHealth = humanoid.Health

    humanoid:GetPropertyChangedSignal("Health"):Connect(function()
        local newHealth = humanoid.Health
        if newHealth < (lastHealth or newHealth) then
            -- someone hit you; try to attribute
            -- priority: recent remote events (recentHitLog), creator tags, touch info, scan
            local recent = recentHitLog[LocalPlayer.Name]
            if recent and now() - recent.time <= HIT_ATTRIBUTION_WINDOW then
                registerAttacker(recent.attacker)
            else
                local name = findCreatorFromWorkspaceNearby()
                if not name then name = scanForLikelyAttacker() end
                if not name then
                    -- final fallback: mark Unknown but include timestamp to debug
                    registerAttacker("Unknown")
                else
                    registerAttacker(name)
                end
            end
        end
        lastHealth = newHealth
    end)
end

-- ========== KILL / DEATH ATTRIBUTION ==========
-- Keep track of recent hits (victim->attacker) via any detection method
-- When a player's humanoid dies, check recentHitLog[victim] and if attacker matches selected target, update kill counts.

local function onAnyCharacterDied(character)
    -- character is the Model that died; try to find player
    if not character then return end
    local victimPlayer = nil
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl.Character == character then victimPlayer = pl; break end
    end
    if not victimPlayer then return end
    local vName = victimPlayer.Name
    local r = recentHitLog[vName]
    if r and now() - r.time <= HIT_ATTRIBUTION_WINDOW then
        local attacker = r.attacker
        -- If we killed them (we were attacker), check selected target
        if attacker == LocalPlayer.Name and selectedKillTarget == vName then
            killStats.kills = killStats.kills + 1
        end
        -- If they killed us (we are victim), and selectedKillTarget == attacker, add to deaths
        if vName == LocalPlayer.Name and r.attacker and selectedKillTarget == r.attacker then
            killStats.deaths = killStats.deaths + 1
        end
    end
    -- clear their recent hit entry (so subsequent deaths are fresh)
    recentHitLog[vName] = nil
end

-- Connect to deaths of all characters (players)
local function connectGlobalDeathWatcher()
    -- connect to existing characters
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl.Character and pl.Character:FindFirstChildOfClass("Humanoid") then
            local humanoid = pl.Character:FindFirstChildOfClass("Humanoid")
            humanoid.Died:Connect(function() onAnyCharacterDied(pl.Character) end)
        end
        pl.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid")
            char:FindFirstChildOfClass("Humanoid").Died:Connect(function() onAnyCharacterDied(char) end)
        end)
    end
    -- new players
    Players.PlayerAdded:Connect(function(pl)
        pl.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid")
            char:FindFirstChildOfClass("Humanoid").Died:Connect(function() onAnyCharacterDied(char) end)
        end)
    end)
end

-- ========== UI (top-center + two-page panel) ==========
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "AttackerTrackerV2"
screenGui.ResetOnSpawn = false
screenGui.Parent = PlayerGui

-- Mobile scaling: adjust sizes based on viewport
local function uiScale()
    local sx, sy = workspace.CurrentCamera.ViewportSize.X, workspace.CurrentCamera.ViewportSize.Y
    local scale = 1
    if UserInputService.TouchEnabled then
        scale = clamp(math.min(sx, sy) / 800, 0.65, 1) -- smaller on phones
    else
        scale = clamp(math.min(sx, sy) / 1100, 0.9, 1.1)
    end
    return scale
end

-- Top-center toggle button
local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "AttackerToggle"
toggleBtn.AnchorPoint = Vector2.new(0.5, 0)
toggleBtn.Size = UDim2.new(0, 240, 0, 40)
toggleBtn.Position = UDim2.new(0.5, 0, 0, 8)
toggleBtn.BackgroundColor3 = Color3.fromRGB(26, 26, 30)
toggleBtn.BorderSizePixel = 0
toggleBtn.Text = "Attackers: 0"
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 16
toggleBtn.TextColor3 = Color3.fromRGB(230,230,230)
toggleBtn.Parent = screenGui
Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0,8)

-- Panel
local panel = Instance.new("Frame")
panel.Name = "MainPanel"
panel.Size = UDim2.new(0, 460, 0, 340)
panel.Position = UDim2.new(0.5, -230, 0, 56)
panel.BackgroundColor3 = Color3.fromRGB(18,18,22)
panel.Visible = false
panel.Parent = screenGui
Instance.new("UICorner", panel).CornerRadius = UDim.new(0,10)

-- Left column (buttons)
local leftCol = Instance.new("Frame", panel")
leftCol.Name = "LeftCol"
leftCol.Size = UDim2.new(0, 104, 1, 0)
leftCol.Position = UDim2.new(0, 8, 0, 8)
leftCol.BackgroundTransparency = 1

-- Buttons for pages
local trackerBtn = Instance.new("TextButton", leftCol)
trackerBtn.Size = UDim2.new(1, -8, 0, 44)
trackerBtn.Position = UDim2.new(0, 4, 0, 0)
trackerBtn.Text = "Tracker"
trackerBtn.Font = Enum.Font.GothamBold
trackerBtn.TextSize = 14
trackerBtn.BackgroundColor3 = Color3.fromRGB(38, 38, 44)
trackerBtn.TextColor3 = Color3.fromRGB(220,220,220)
Instance.new("UICorner", trackerBtn).CornerRadius = UDim.new(0,8)

local killTrackerBtn = Instance.new("TextButton", leftCol)
killTrackerBtn.Size = UDim2.new(1, -8, 0, 44)
killTrackerBtn.Position = UDim2.new(0, 4, 0, 56)
killTrackerBtn.Text = "Kill Tracker"
killTrackerBtn.Font = Enum.Font.GothamBold
killTrackerBtn.TextSize = 14
killTrackerBtn.BackgroundColor3 = Color3.fromRGB(28, 28, 34)
killTrackerBtn.TextColor3 = Color3.fromRGB(200,200,200)
Instance.new("UICorner", killTrackerBtn).CornerRadius = UDim.new(0,8)

-- Right content area
local content = Instance.new("Frame", panel)
content.Size = UDim2.new(1, -128, 1, -16)
content.Position = UDim2.new(0, 120, 0, 8)
content.BackgroundTransparency = 1

-- Tracker page
local trackerPage = Instance.new("Frame", content)
trackerPage.Size = UDim2.new(1,0,1,0)
trackerPage.BackgroundTransparency = 1
trackerPage.Visible = true

local liveLabel = Instance.new("TextLabel", trackerPage)
liveLabel.Size = UDim2.new(1, -12, 0, 24)
liveLabel.Position = UDim2.new(0, 6, 0, 0)
liveLabel.BackgroundTransparency = 1
liveLabel.Font = Enum.Font.GothamBold
liveLabel.TextSize = 14
liveLabel.TextColor3 = Color3.fromRGB(230,230,230)
liveLabel.TextXAlignment = Enum.TextXAlignment.Left

local liveScroll = Instance.new("ScrollingFrame", trackerPage)
liveScroll.Position = UDim2.new(0, 6, 0, 30)
liveScroll.Size = UDim2.new(1, -12, 0, 150)
liveScroll.BackgroundTransparency = 1
local liveLayout = Instance.new("UIListLayout", liveScroll); liveLayout.Padding = UDim.new(0,6)

local historyLabel = Instance.new("TextLabel", trackerPage)
historyLabel.Position = UDim2.new(0, 6, 0, 188)
historyLabel.Size = UDim2.new(1, -12, 0, 20)
historyLabel.BackgroundTransparency = 1
historyLabel.Font = Enum.Font.GothamBold
historyLabel.TextSize = 13
historyLabel.TextColor3 = Color3.fromRGB(190,190,190)
historyLabel.Text = "History:"

local historyScroll = Instance.new("ScrollingFrame", trackerPage)
historyScroll.Position = UDim2.new(0, 6, 0, 210)
historyScroll.Size = UDim2.new(1, -12, 0, 120)
historyScroll.BackgroundTransparency = 1
local historyLayout = Instance.new("UIListLayout", historyScroll); historyLayout.Padding = UDim.new(0,4)

-- Kill Tracker page
local killPage = Instance.new("Frame", content)
killPage.Size = UDim2.new(1,0,1,0)
killPage.BackgroundTransparency = 1
killPage.Visible = false

local selectLabel = Instance.new("TextLabel", killPage)
selectLabel.Position = UDim2.new(0,6,0,0)
selectLabel.Size = UDim2.new(1,-12,0,22)
selectLabel.BackgroundTransparency = 1
selectLabel.Font = Enum.Font.GothamBold
selectLabel.TextSize = 14
selectLabel.TextColor3 = Color3.fromRGB(230,230,230)
selectLabel.Text = "Select player to track:"

local playerList = Instance.new("ScrollingFrame", killPage)
playerList.Position = UDim2.new(0,6,0,26)
playerList.Size = UDim2.new(1,-12,0,160)
playerList.BackgroundTransparency = 1
local playerListLayout = Instance.new("UIListLayout", playerList); playerListLayout.Padding = UDim.new(0,4)

local statsLabel = Instance.new("TextLabel", killPage)
statsLabel.Position = UDim2.new(0,6,0,194)
statsLabel.Size = UDim2.new(1,-12,0,60)
statsLabel.BackgroundTransparency = 1
statsLabel.Font = Enum.Font.Gotham
statsLabel.TextSize = 14
statsLabel.TextColor3 = Color3.fromRGB(220,220,220)
statsLabel.Text = "Kills: 0\nDeaths: 0\nSelected: none"

local resetBtn = Instance.new("TextButton", killPage)
resetBtn.Position = UDim2.new(0,6,0,260)
resetBtn.Size = UDim2.new(0,100,0,30)
resetBtn.Text = "Reset"
resetBtn.Font = Enum.Font.GothamBold
resetBtn.TextColor3 = Color3.fromRGB(220,220,220)
resetBtn.BackgroundColor3 = Color3.fromRGB(70,0,0)
Instance.new("UICorner", resetBtn).CornerRadius = UDim.new(0,6)

-- ========== UI FUNCTIONS ==========
local function clearChildren(frame)
    for _,c in ipairs(frame:GetChildren()) do
        if not (c:IsA("UIListLayout") or c:IsA("UISizeConstraint")) then
            c:Destroy()
        end
    end
end

local function makeLiveEntry(name, hits, expires)
    local f = Instance.new("Frame")
    f.Size = UDim2.new(1, -6, 0, 28)
    f.BackgroundTransparency = 0.12
    f.BorderSizePixel = 0
    f.Parent = liveScroll
    local lbl = Instance.new("TextLabel", f)
    lbl.Size = UDim2.new(1, -12, 1, 0)
    lbl.Position = UDim2.new(0,8,0,0)
    lbl.BackgroundTransparency = 1
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 13
    lbl.TextColor3 = Color3.fromRGB(230,230,230)
    lbl.TextXAlignment = Enum.TextXAlignment.Left
    lbl.Text = string.format("%s — hits: %d — expires in: %ds", name, hits, math.floor(expires))
end

local function makeHistoryEntry(item)
    local lbl = Instance.new("TextLabel")
    lbl.Size = UDim2.new(1, -6, 0, 20)
    lbl.BackgroundTransparency = 0.2
    lbl.Font = Enum.Font.Gotham
    lbl.TextSize = 12
    lbl.TextColor3 = Color3.fromRGB(200,200,200)
    local first = os.date("%X", item.timeFirst)
    local last = os.date("%X", item.timeLast)
    lbl.Text = string.format("%s — hits: %d — %s → %s", item.name, item.hits, first, last)
    lbl.Parent = historyScroll
end

local function refreshLiveUI()
    clearChildren(liveScroll)
    clearChildren(historyScroll)
    local count = 0
    for name, data in pairs(attackers) do
        local expires = INACTIVITY_TIMEOUT - (now() - data.lastHit)
        if expires < 0 then expires = 0 end
        makeLiveEntry(name, data.hits, expires)
        count = count + 1
    end
    local hcount = math.min(#history, MAX_HISTORY_SHOWN)
    for i=1, hcount do
        makeHistoryEntry(history[i])
    end
    liveLabel.Text = "Live Attackers — Count: " .. tostring(count)
    toggleBtn.Text = "Attackers: " .. tostring(count)
end

local function refreshPlayerList()
    clearChildren(playerList)
    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer then
            local btn = Instance.new("TextButton")
            btn.Size = UDim2.new(1, -8, 0, 28)
            btn.Position = UDim2.new(0,4,0,0)
            btn.BackgroundColor3 = Color3.fromRGB(34,34,38)
            btn.Font = Enum.Font.Gotham
            btn.TextSize = 14
            btn.TextColor3 = Color3.fromRGB(230,230,230)
            btn.Text = pl.Name
            btn.Parent = playerList
            btn.MouseButton1Click:Connect(function()
                -- select or deselect
                if selectedKillTarget == pl.Name then
                    selectedKillTarget = nil
                    killStats = { kills = 0, deaths = 0 }
                else
                    selectedKillTarget = pl.Name
                    killStats = { kills = 0, deaths = 0 }
                end
                statsLabel.Text = string.format("Kills: %d\nDeaths: %d\nSelected: %s", killStats.kills, killStats.deaths, tostring(selectedKillTarget or "none"))
            end)
        end
    end
end

-- page switching
trackerBtn.MouseButton1Click:Connect(function()
    trackerPage.Visible = true
    killPage.Visible = false
    trackerBtn.BackgroundColor3 = Color3.fromRGB(38,38,44)
    killTrackerBtn.BackgroundColor3 = Color3.fromRGB(28,28,34)
end)
killTrackerBtn.MouseButton1Click:Connect(function()
    trackerPage.Visible = false
    killPage.Visible = true
    trackerBtn.BackgroundColor3 = Color3.fromRGB(28,28,34)
    killTrackerBtn.BackgroundColor3 = Color3.fromRGB(38,38,44)
    refreshPlayerList()
end)

toggleBtn.MouseButton1Click:Connect(function()
    panel.Visible = not panel.Visible
end)

resetBtn.MouseButton1Click:Connect(function()
    selectedKillTarget = nil
    killStats = { kills = 0, deaths = 0 }
    statsLabel.Text = string.format("Kills: %d\nDeaths: %d\nSelected: %s", killStats.kills, killStats.deaths, tostring(selectedKillTarget or "none"))
end)

-- update function for kill stats display
local function updateKillStatsDisplay()
    statsLabel.Text = string.format("Kills: %d\nDeaths: %d\nSelected: %s", killStats.kills, killStats.deaths, tostring(selectedKillTarget or "none"))
end

-- UI initial style
trackerBtn.BackgroundColor3 = Color3.fromRGB(38,38,44)
killTrackerBtn.BackgroundColor3 = Color3.fromRGB(28,28,34)

-- ========== HOOKS / CONNECTS ==========
-- FightRemote hookup
FightRemote = findFightRemote()
if FightRemote then
    -- prefer OnClientEvent payloads for attacker/victim data
    FightRemote.OnClientEvent:Connect(handleFightRemoteEvent)
end

-- Touch detectors for local character
LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(0.4)
    disconnectTouchDetectors()
    connectTouchDetectors(char)
    hookHealthWatcher()
end)
if LocalPlayer.Character then
    connectTouchDetectors(LocalPlayer.Character)
    hookHealthWatcher()
end

-- Global death watcher (for kill attribution)
connectGlobalDeathWatcher()

-- Periodic housekeeping / UI tick
spawn(function()
    while screenGui.Parent do
        archiveAllExpired()
        refreshLiveUI()
        updateKillStatsDisplay()
        -- trim recentHitLog entries older than HIT_ATTRIBUTION_WINDOW * 2
        local t = now()
        for v, rec in pairs(recentHitLog) do
            if t - rec.time > HIT_ATTRIBUTION_WINDOW * 2 then recentHitLog[v] = nil end
        end
        task.wait(POLL_INTERVAL)
    end
end)

-- react to player list changes to keep Kill Tracker list fresh
Players.PlayerAdded:Connect(refreshPlayerList)
Players.PlayerRemoving:Connect(function()
    refreshPlayerList()
    -- if selected left, clear stats
    if selectedKillTarget and not Players:FindFirstChild(selectedKillTarget) then
        selectedKillTarget = nil
        killStats = { kills = 0, deaths = 0 }
    end
end)

-- expose for debug
_G.AttackerTracker = {
    Register = function(name) registerAttacker(name) end,
    RecentHits = recentHitLog,
    Attackers = attackers,
    History = history,
    Config = { INACTIVITY_TIMEOUT = INACTIVITY_TIMEOUT, SCAN_RADIUS = SCAN_RADIUS, HIT_ATTRIBUTION_WINDOW = HIT_ATTRIBUTION_WINDOW }
}

print("[AttackerTrackerV2] Initialized. Toggle at top-center. FightRemote:", tostring(FightRemote and FightRemote.Name or "nil"))
