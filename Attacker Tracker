-- Attacker Tracker (LocalScript)
-- Place in StarterPlayerScripts or run via executor in your testing place

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- CONFIG
local INACTIVITY_TIMEOUT = 5       -- seconds until an attacker is removed when no new hits
local SCAN_RADIUS = 16             -- radius to search for likely attackers when health drops
local POLL_INTERVAL = 0.25         -- UI / housekeeping tick
local HISTORY_MAX = 200            -- keep last N attackers in history

-- Try to find a remote commonly named "FightEvent" (may be nil)
local function findFightRemote()
    local remote = ReplicatedStorage:FindFirstChild("FightEvent") -- common name
    if remote then return remote end
    -- scan ReplicatedStorage (shallow)
    for _, v in ipairs(ReplicatedStorage:GetChildren()) do
        if v:IsA("RemoteEvent") and v.Name:lower():match("fight") then
            return v
        end
    end
    return nil
end

local FightRemote = findFightRemote()

-- Data structures
local attackers = {}   -- attackers[name] = {lastHit = os.time(), hits = n}
local history = {}     -- array of {name, timeFirst, timeLast, hits}
local uiOpen = false

-- Utility: add or refresh attacker
local function registerAttacker(name)
    if not name then return end
    local t = os.time()
    local entry = attackers[name]
    if entry then
        entry.lastHit = t
        entry.hits = entry.hits + 1
    else
        attackers[name] = { lastHit = t, hits = 1, firstSeen = t }
    end
end

-- Utility: move attacker to history and remove from attackers list
local function archiveAttacker(name)
    local entry = attackers[name]
    if not entry then return end
    table.insert(history, 1, {
        name = name,
        timeFirst = entry.firstSeen,
        timeLast = entry.lastHit,
        hits = entry.hits
    })
    -- clamp history size
    while #history > HISTORY_MAX do table.remove(history) end
    attackers[name] = nil
end

-- Heuristic scanning on health loss:
-- attempt to find a player who likely caused the damage:
local function scanForLikelyAttacker()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return nil end
    local myPos = char.HumanoidRootPart.Position

    local best = nil
    local bestScore = math.huge

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= LocalPlayer and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local root = pl.Character.HumanoidRootPart
            local dist = (root.Position - myPos).Magnitude
            if dist <= SCAN_RADIUS then
                -- prefer closer players; check if they hold tools
                local holdingTool = false
                for _, c in ipairs(pl.Character:GetChildren()) do
                    if c:IsA("Tool") then holdingTool = true; break end
                end
                local score = dist - (holdingTool and 2 or 0)
                if score < bestScore then
                    bestScore = score
                    best = pl
                end
            end
        end
    end

    if best then return best.Name end
    return nil
end

-- More advanced: try to detect creator tag on nearby parts/tools (common pattern)
local function findCreatorFromWorkspaceNearby()
    local char = LocalPlayer.Character
    if not char or not char:FindFirstChild("HumanoidRootPart") then return nil end
    local rootPos = char.HumanoidRootPart.Position
    -- iterate tools and objects closeby for creator ObjectValue or StringValue tags
    for _, object in ipairs(workspace:GetDescendants()) do
        if object:IsA("BasePart") then
            local d = (object.Position - rootPos).Magnitude
            if d <= SCAN_RADIUS then
                -- check for common creator tag names
                local creator = object:FindFirstChild("creator") or object:FindFirstChild("Creator") or object:FindFirstChild("Owner")
                if creator and (creator.Value and typeof(creator.Value) == "Instance" and creator.Value:IsA("Player")) then
                    return creator.Value.Name
                elseif creator and type(creator.Value) == "string" then
                    return creator.Value
                end
                -- check parent for a tool or model with a creator
                local parent = object.Parent
                if parent then
                    local ctag = parent:FindFirstChild("creator") or parent:FindFirstChild("Creator")
                    if ctag and ctag.Value and typeof(ctag.Value) == "Instance" and ctag.Value:IsA("Player") then
                        return ctag.Value.Name
                    end
                end
            end
        end
    end
    return nil
end

-- Primary detection via FightRemote (if exists):
if FightRemote and FightRemote.IsA and FightRemote:IsA("RemoteEvent") then
    -- Server may send a payload: attacker (Player/Name), or {attacker, damage}, etc
    FightRemote.OnClientEvent:Connect(function(...)
        local args = {...}
        -- Try to extract attacker info from common payload shapes
        local attackerName = nil
        if #args >= 1 then
            local a = args[1]
            if typeof(a) == "Instance" and a:IsA("Player") then
                attackerName = a.Name
            elseif type(a) == "string" then
                attackerName = a
            elseif type(a) == "table" then
                -- table might contain attacker = player
                if a.attacker and typeof(a.attacker) == "Instance" and a.attacker:IsA("Player") then
                    attackerName = a.attacker.Name
                elseif a.attackerName and type(a.attackerName) == "string" then
                    attackerName = a.attackerName
                end
            end
        end
        if attackerName then
            registerAttacker(attackerName)
        end
    end)
end

-- Secondary detection via Humanoid health changes
local lastHealth = nil
local function hookHealthWatcher()
    local char = LocalPlayer.Character
    if not char then return end
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    lastHealth = humanoid.Health

    humanoid:GetPropertyChangedSignal("Health"):Connect(function()
        local new = humanoid.Health
        if new < (lastHealth or new) then
            -- health decreased -> try identify attacker
            -- try creator tags first
            local name = findCreatorFromWorkspaceNearby()
            if not name then
                name = scanForLikelyAttacker()
            end
            if not name then
                -- fallback to generic "Unknown" with timestamp to track in UI
                name = "Unknown"
            end
            registerAttacker(name)
        end
        lastHealth = new
    end)
end

-- Attach health watcher whenever character spawns
Players.LocalPlayer.CharacterAdded:Connect(function(char)
    wait(0.5)
    hookHealthWatcher()
end)
if Players.LocalPlayer.Character then
    hookHealthWatcher()
end

-- Housekeeping: remove inactive attackers after timeout
local function cleanupInactive()
    local now = os.time()
    for name, data in pairs(attackers) do
        if now - data.lastHit >= INACTIVITY_TIMEOUT then
            archiveAttacker(name)
        end
    end
end

-- ---------------------------
-- UI: Toggle button + panel
-- ---------------------------
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")
local screen = Instance.new("ScreenGui")
screen.Name = "AttackerTrackerGUI"
screen.ResetOnSpawn = false
screen.Parent = PlayerGui

-- Toggle button
local toggleBtn = Instance.new("TextButton")
toggleBtn.Size = UDim2.new(0, 180, 0, 36)
toggleBtn.Position = UDim2.new(0, 10, 0, 120)
toggleBtn.AnchorPoint = Vector2.new(0,0)
toggleBtn.Text = "Attackers: 0"
toggleBtn.Font = Enum.Font.GothamBold
toggleBtn.TextSize = 14
toggleBtn.BackgroundColor3 = Color3.fromRGB(30,30,30)
toggleBtn.TextColor3 = Color3.fromRGB(220,220,220)
toggleBtn.Parent = screen
toggleBtn.AutoButtonColor = true
local corner = Instance.new("UICorner", toggleBtn); corner.CornerRadius = UDim.new(0,8)

-- Panel
local panel = Instance.new("Frame")
panel.Size = UDim2.new(0, 360, 0, 300)
panel.Position = UDim2.new(0, 10, 0, 160)
panel.BackgroundColor3 = Color3.fromRGB(18,18,22)
panel.Visible = false
panel.Parent = screen
Instance.new("UICorner", panel).CornerRadius = UDim.new(0,10)

-- Header on panel
local header = Instance.new("TextLabel")
header.Size = UDim2.new(1, -12, 0, 30)
header.Position = UDim2.new(0, 6, 0, 6)
header.BackgroundTransparency = 1
header.Text = "Attacker Tracking Hub"
header.Font = Enum.Font.GothamBold
header.TextSize = 16
header.TextColor3 = Color3.fromRGB(235,235,235)
header.Parent = panel

-- Live list container
local liveLabel = Instance.new("TextLabel", panel)
liveLabel.Size = UDim2.new(1, -12, 0, 22)
liveLabel.Position = UDim2.new(0, 6, 0, 40)
liveLabel.BackgroundTransparency = 1
liveLabel.Font = Enum.Font.Gotham
liveLabel.TextSize = 13
liveLabel.TextColor3 = Color3.fromRGB(200,200,200)
liveLabel.TextXAlignment = Enum.TextXAlignment.Left

local liveScroll = Instance.new("ScrollingFrame")
liveScroll.Size = UDim2.new(1, -12, 0, 120)
liveScroll.Position = UDim2.new(0, 6, 0, 64)
liveScroll.BackgroundTransparency = 1
liveScroll.ScrollBarThickness = 6
liveScroll.Parent = panel
local liveLayout = Instance.new("UIListLayout", liveScroll)
liveLayout.Padding = UDim.new(0,6)

-- History pane
local historyLabel = Instance.new("TextLabel", panel)
historyLabel.Size = UDim2.new(1, -12, 0, 20)
historyLabel.Position = UDim2.new(0, 6, 0, 190)
historyLabel.BackgroundTransparency = 1
historyLabel.Font = Enum.Font.Gotham
historyLabel.TextSize = 13
historyLabel.TextColor3 = Color3.fromRGB(190,190,190)
historyLabel.TextXAlignment = Enum.TextXAlignment.Left
historyLabel.Text = "History:"

local historyScroll = Instance.new("ScrollingFrame")
historyScroll.Size = UDim2.new(1, -12, 0, 100)
historyScroll.Position = UDim2.new(0, 6, 0, 212)
historyScroll.BackgroundTransparency = 1
historyScroll.ScrollBarThickness = 6
historyScroll.Parent = panel
local historyLayout = Instance.new("UIListLayout", historyScroll)
historyLayout.Padding = UDim.new(0,4)

-- Small status line
local statusLine = Instance.new("TextLabel", panel)
statusLine.Size = UDim2.new(1, -12, 0, 18)
statusLine.Position = UDim2.new(0, 6, 0, 280)
statusLine.BackgroundTransparency = 1
statusLine.Font = Enum.Font.Gotham
statusLine.TextSize = 12
statusLine.TextColor3 = Color3.fromRGB(160,160,160)
statusLine.TextXAlignment = Enum.TextXAlignment.Left
statusLine.Text = "Tracker active — using heuristics."

-- Toggle behavior
toggleBtn.MouseButton1Click:Connect(function()
    panel.Visible = not panel.Visible
end)

-- Small helper to create list entry
local function makeLiveEntry(name, hits, timeLeft)
    local btn = Instance.new("Frame")
    btn.Size = UDim2.new(1, -12, 0, 28)
    btn.BackgroundTransparency = 0.12
    btn.BorderSizePixel = 0
    btn.Parent = liveScroll
    local t = Instance.new("TextLabel", btn)
    t.Size = UDim2.new(1, -8, 1, 0)
    t.Position = UDim2.new(0, 6, 0, 0)
    t.BackgroundTransparency = 1
    t.Font = Enum.Font.Gotham
    t.TextSize = 13
    t.TextColor3 = Color3.fromRGB(230,230,230)
    t.TextXAlignment = Enum.TextXAlignment.Left
    t.Text = string.format("%s — hits: %d — expires in: %ds", name, hits, timeLeft)
    return btn
end

local function makeHistoryEntry(name, hits, firstTS, lastTS)
    local btn = Instance.new("TextLabel")
    btn.Size = UDim2.new(1, -12, 0, 22)
    btn.BackgroundTransparency = 0.2
    btn.TextXAlignment = Enum.TextXAlignment.Left
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 12
    btn.TextColor3 = Color3.fromRGB(200,200,200)
    local first = os.date("%X", firstTS)
    local last = os.date("%X", lastTS)
    btn.Text = string.format("%s — hits: %d — %s → %s", name, hits, first, last)
    btn.Parent = historyScroll
    return btn
end

-- Update UI
local function refreshUI()
    -- clear live
    for _,c in ipairs(liveScroll:GetChildren()) do if c:IsA("Frame") or c:IsA("TextLabel") then c:Destroy() end end
    -- fill
    local now = os.time()
    local count = 0
    for name,data in pairs(attackers) do
        local timeLeft = math.max(0, INACTIVITY_TIMEOUT - (now - data.lastHit))
        makeLiveEntry(name, data.hits, timeLeft)
        count = count + 1
    end
    liveLabel.Text = "Live Attackers — Count: " .. tostring(count)
    toggleBtn.Text = "Attackers: " .. tostring(count)

    -- refresh history (show up to 20 recent)
    for _,c in ipairs(historyScroll:GetChildren()) do if c:IsA("TextLabel") then c:Destroy() end end
    local shown = 0
    for i=1, math.min(#history, 20) do
        local item = history[i]
        makeHistoryEntry(item.name, item.hits, item.timeFirst, item.timeLast)
        shown = shown + 1
    end
end

-- Periodic housekeeping + UI tick
spawn(function()
    while screen.Parent do
        cleanupInactive()
        refreshUI()
        task.wait(POLL_INTERVAL)
    end
end)

-- Expose some functions for quick testing in console
_G.AttackerTracker = {
    Register = registerAttacker,
    Archive = archiveAttacker,
    GetCurrent = function() local t={} for k,v in pairs(attackers) do t[k]=v end return t end,
    GetHistory = function() return history end
}

print("[AttackerTracker] Initialized. GUI toggle at top-left. Uses FightEvent if available.")
